#+TITLE: Linux 记录
#+AUTHOR: Liu, Shijie
#+LANGUAGE: zh
#+TEXINFO_DIR_CATEGORY: Emacs
#+OPTIONS: ^:{} toc:t H:5 num:0

* 目录
- [[#%E6%8C%87%E4%BB%A4][指令]]
- [[$shell-%E8%84%9A%E6%9C%AC][shell 脚本]]
  - [[#%E5%8F%98%E9%87%8F][变量]]
  - [[#%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95][条件测试]]

* 指令
- awk

- cut

- echo

- eval

- exec

- grep

- sed

* shell 脚本
- shebang，魔数，幻数
#+BEGIN_SRC shell
#!/bin/bash
# comment lines
#+END_SRC
- 命令行下输入命令，没有给定路径时，系统默认到$PATH中查找；
** 辅助
| 算数运算符   | 含义       |
| +、-         | 加、减     |
| *、/、%       | 乘、除、模 |
| **            | 幂运算     |
| ++、--       |            |
| !、&&、\vert | 非、与、或 |
|              |            |
- 算术运算：
  - + - * /
  - %（求余），==（相等），=，!=，!（非），-o（或），-a（与）
  - 执行方法
    - let 算术运算表达式
    - $[算术运算表达式]
    - ((算术运算表达式))
    - expr 算术运算表达式:  表达式中各操作数及运算符之间要有空格
- 测试脚本执行
  - bash -n 脚本：检查脚本（主要）错误
  - bash -x 脚本：单步执行脚本
- 退出脚本
  - exit #(数字，0为正确执行，1-255为执行错误)
** 变量
*** 变量类型
- 环境变量：作用域为当前 shell 进程及其子进程；
  - export VARNAME=VALUE 或 VARNAME=VALUE；export VARNAME
- 本地变量 (局部变量)：
  - VARNAME=VALUE：本地变量，整个 bash 进程；
  - local VARNAME=VALUE; 局部变量，
- 位置变量：
  - $0：获取当前执行脚本的文件名
  - $n：获取当前执行脚本的第n个参数值，n>10时，需用{}括起来，${11}
  - shift 参数轮替
- 特殊变量：
  - $?：上一个命令的执行状态返回值
  - $$：返回当前 shell 的 ID
  - $#：参数的个数
  - $*：参数列表，不加引号与$@相同，加上引号，则表示将所有参数视为单个字符串，相当于“$1 $2”
  - $@：参数列表，不加引号与$*相同，加上引号，则表示将每个参数视为单个字符串，相当于“$1“ ”$2”
*** 变量修改
- 脚本在执行时会启动一个子 shell 进程
  - 命令行中启动的脚本会继承当前 shell 环境变量；
  - 系统自动执行的脚本（非命令行启动）需要自我定义需要的环境变量；
- ‘’为强替换，“”为
- 引用变量：${VARNAME}
  - 在变量名不引起混淆的情况下，花括号可以省略；
  -
- 撤销变量：unset VARNAME
- 查看变量
  - env, printenv, export：查看当前 shell 中的环境变量
  - set 查看当前 shell 中的所有变量，包括环境变量

** 字符串操作
*** 字符串截取、删除和替换
| 表达式                | 说明                                            |
| ${var}                | 返回变量var的内容                               |
| ${var}                | 返回变量var的内容的长度（字符），适用于特殊变量 |
| ${var:offset}         | 从offset提取字符串到结尾                        |
| ${var:offset:length}  | 从offset位置开始提取长度为length的子字符串      |
| ${var#"word"}           | 从开头开始删除最短匹配的"word"子串                |
| ${var##"word"}          | 从开头开始删除最长匹配的"word"子串                |
| ${var%"word"}           | 从结尾开始删除最短匹配的"word"子串                |
| ${var%%"word"}          | 从结尾开始删除最长匹配的"word"子串                |
| ${var/pattern/string} | 用string代替第一个匹配的pattern                 |
| ${var//patern/string} | 用string代替所有匹配的pattern                   |

*** 字符串检查与赋值
| 表达式       | 说明                                                                    |
| ${var:-"word"} | 如果变量var为空或未赋值，则返回"word"字符串                               |
| ${var:="word"} | 如果变量var为空或未赋值，则将"word"字符串赋给var，同时返回"word"            |
| ${var:?"word"} | 如果变量var为空或未赋值，则"word"字符串将作为标准错误输出，否则输出变量值 |
| ${var:+"word"} | 如果变量var为空或未赋值，则无动作，否则"word"字符串替换变量的值           |

:-和:=方法示例：
#+BEGIN_SRC shell
[userName@localhost shell_script]$ echo $var1 $var2

[userName@localhost shell_script]$ var2=${var1:-hello}
[userName@localhost shell_script]$ echo $var1

[userName@localhost shell_script]$ echo $var2
hello
[userName@localhost shell_script]$ unset var1 var2
[userName@localhost shell_script]$ var2=${var1:=hello}
[userName@localhost shell_script]$ echo $var1
hello
[userName@localhost shell_script]$ echo $var2
hello
#+END_SRC

** 条件测试
*** 条件测试表达式
#+BEGIN_SRC shell
[ expression ]   # 中括号中必须要有空格
[[ expression ]]
test expression
#+END_SRC

*** 整数测试
- -eq
#+BEGIN_SRC shell
[userName@localhost ~]$ a=3;b=6;[ $a -eq $b ];echo $?
1
#+END_SRC
- -ne
- -gt
- -lt
- -ge
- -le
*** 字符测试
- =：字符串

*** 文件测试
- -e FILE：测试文件是否存在
- -f FILE：测试文件是否为普通文件
- -d FILE：测试指定路径是否为目录
- -r FILE：测试当前用户对指定文件是否有读取权限
- -w FILE：测试当前用户对指定文件是否有写入权限
- -x FILE：测试当前用户对指定文件是否有执行权限

*** 逻辑测试
- &&
#+BEGIN_SRC shell
[userName@localhost ~]$ id userName &> /dev/null && echo "hello, $USER"
hello, userName
#+END_SRC
- ||
- !
#+BEGIN_SRC shell
[userName@localhost ~]$ ! id userName && useradd userName
#+END_SRC
** 控制结构
*** if 结构
- 单分支 if 分支
#+BEGIN_SRC shell
if 判断条件; then
  statemen1
  statemen2
fi
#+END_SRC
- 多分支 if 分支
#+BEGIN_SRC shell
if 判断条件; then
  statemen1
  statemen2
elif 判断条件; then
  statemen3
  statemen4
else
  statemen5
  statemen6
fi
#+END_SRC

* For fun
** PS1
#+BEGIN_SRC shell
[userName@localhost shell_script]$ echo $PS1
[\u@\h \W]\$
#+END_SRC
PS1 定义了命令提示字符，可以自定义：
- \d ：可显示出“星期 月 日”的日期格式，如："Mon Feb 2"
- \H ：完整的主机名称。
- \h ：仅取主机名称在第一个小数点之前的名字
- \t ：显示时间，为 24 小时格式的“HH:MM:SS”
- \T ：显示时间，为 12 小时格式的“HH:MM:SS”
- \A ：显示时间，为 24 小时格式的“HH:MM”
- \@ ：显示时间，为 12 小时格式的“am/pm”样式
- \u ：目前使用者的帐号名称，如“dmtsai”；
- \v ：BASH 的版本信息，如测试主机版本为 4.2.46（1）-release，仅取“4.2”显示
- \w ：完整的工作目录名称，由根目录写起的目录名称。家目录会以 ~ 取代；
- \W ：利用 basename 函数取得工作目录名称，所以仅会列出最后一个目录名。
- # ：下达的第几个指令。
- $ ：提示字符，如果是 root 时，提示字符为 # ，否则就是 $ 啰～
#+BEGIN_SRC shell
[userName@localhost shell_script]$ PS1='[\u@\h \w \A #\#]\$ '
[userName@localhost ~/shell_script 05:11 #77]$
#+END_SRC
**  bash 登入与欢迎：/etc/issue, /etc/motd

* 网络配置
** 其他
- 网络配置文件：
  #+BEGIN_EXAMPLE
  /etc/sysconfig/network-scripts/ifcfg-
  #+END_EXAMPLE

  - 重启网络：
  #+BEGIN_SRC shell
  systemctl restart network
  #+END_SRC

  - 查看网卡信息：
  #+BEGIN_SRC shell
  nmcli connection show
  #+END_SRC

  - 命令行模式下网卡修改：
  #+BEGIN_SRC shell
  nmtui
  #+END_SRC

* 远程连接
  - ssh [-f] [-o 参数项目] [-p 非默认端口(默认为 22 )] [账号@]IP [指令]
  -f:主机上执行指令，界面跳回客户端，即不等待主机上指令的执行过程

  -o:

  ConnectTimeout=秒数

  StrictHostKeyChecking=[yes|no|ask(预设)]:当第一次远程到一个主机时，会被询问 "Are you sure you want to continue connecting (yes/no)? ". 当批量执行时，每次问就会很麻烦，这时 StrictHostKeyChecking=no 就是个不错的选择。

  #+BEGIN_EXAMPLE
  $ ssh -f root@some_IP shutdown -h now
  #+END_EXAMPLE

  - sftp
  - scp [-pr] [-l 速率] file [账号@]主机:目录名 <==上传
  scp [-pr] [-l 速率] [账号@]主机:file 目录名 <==下载
  -p ：保留原本档案的权限数据；
  -r ：复制来源为目录时，可以复制整个目录 (含子目录)
  -l ：可以限制传输的速度，单位为 Kbits/s ，例如 [-l 800] 代表传输速限 100Kbytes/s

  - 查看是否安装了openssh-server：
    #+BEGIN_EXAMPLE
    $ yum list installed | grep openssh-server
    #+END_EXAMPLE

  - 如果没有安装，则安装openssh-server：
#+BEGIN_EXAMPLE
$ yum install openssh-server
#+END_EXAMPLE

  - sshd 服务配置文件
    #+BEGIN_SRC shell
    $ /etc/ssh/sshd_config
    #+END_SRC

  - 开启 sshd 服务
    #+BEGIN_SRC shell
    $ sudo service sshd start
    #+END_SRC

  - 检查 sshd 服务是否已经开启：
    #+BEGIN_SRC shell
    $ ps -e | grep sshd
    #+END_SRC

  - 检查 22 号端口是否开启监听：
    #+BEGIN_SRC shell
    $ netstat -an | grep 22
    #+END_SRC

* 防火墙设置
  1. firewalld的基本使用
  - 启动：
    #+BEGIN_SRC shell
    $ systemctl start firewalld
    #+END_SRC

  - 关闭：
    #+BEGIN_SRC shell
    $ systemctl stop firewalld
    #+END_SRC

  - 查看状态：
    #+BEGIN_SRC shell
    $ systemctl status firewalld
    #+END_SRC

  - 开机禁用：
    #+BEGIN_SRC shell
    $ systemctl disable firewalld
    #+END_SRC

  - 开机启用：
    #+BEGIN_SRC shell
    $ systemctl enable firewalld
    #+END_SRC

  2. systemctl是CentOS7的服务管理工具中主要的工具，它融合之前service和chkconfig的功能于一体。
  #+BEGIN_QUOTE
  启动一个服务：systemctl start 服务名
  systemctl start firewalld.service

  关闭一个服务：systemctl stop 服务名
  systemctl stop firewalld.service

  重启一个服务：systemctl restart 服务名
  systemctl restart firewalld.service

  显示一个服务的状态：systemctl status 服务名
  systemctl status firewalld.service

  在开机时启用一个服务：systemctl enable 服务名
  systemctl enable firewalld.service

  在开机时禁用一个服务：systemctl disable 服务名
  systemctl disable firewalld.service

  查看服务是否开机启动：systemctl is-enabled 服务名
  systemctl is-enabled firewalld.service

  查看已启动的服务列表：systemctl list-unit-files|grep enabled

  查看启动失败的服务列表：systemctl --failed
  #+END_QUOTE

  3.配置firewalld-cmd
  查看版本：
  firewall-cmd --version

  查看帮助：
  firewall-cmd --help

  显示状态：
  firewall-cmd --state

  查看所有打开的端口：
  firewall-cmd --zone=public --list-ports

  更新防火墙规则：
  firewall-cmd --reload

  查看区域信息:
  firewall-cmd --get-active-zones

  查看指定接口所属区域：
  firewall-cmd --get-zone-of-interface=eth0

  拒绝所有包：
  firewall-cmd --panic-on

  取消拒绝状态：
  firewall-cmd --panic-off

  查看是否拒绝：
  firewall-cmd --query-panic

  4.那怎么开启一个端口呢

  添加
  firewall-cmd --zone=public --add-port=80/tcp --permanent    （--permanent永久生效，没有此参数重启后失效）

  重新载入
  firewall-cmd --reload

  查看
  firewall-cmd --zone= public --query-port=80/tcp

  删除
  firewall-cmd --zone= public --remove-port=80/tcp --permanent

  查看防火墙状态：
  firewall-cmd --state( centos 7 )

  临时关闭防火墙：
  service iptables stop( centos 6 )
  systemctl stop firewalld( centos 7 )

  禁止开机启动：
  chkconfig iptables off( centos 6 )
  systemctl disable firewalld( centos 7 )
  或 systemctl disable firewalld.service

* git
  1 git 命令行提交代码

  拉取服务器代码：提交代码之前，需先从服务器上拉取代码，以免覆盖别人代码
  git pull

  查看当前工作目录树的工作修改状态
  git status
  -- untracked 未跟踪，此文件在文件夹中，但没有加入到git库中，不参与版本控制，通过git add 状态变为 Staged
  -- Modified文件已修改，仅修改，没有进行其他操作
  -- deleted
  -- renamed

  将状态改变的代码提交至缓存
  git add 文件
  git add -u path/(modified tracked) file
  git add -A path/(modified untracked) file

  将代码提交到本地仓库
  git commit -m "注释，即 GitHub-desktop 中 summary 部分"

  将代码推送至服务器
  git push

当本地和云上的文件都有修改时，会发生代码冲突
#+begin_example
error: Your local changes to the following files would be overwritten by merge:        protected/config/main.phpPlease, commit your changes or stash them before you can merge.
#+end_example
解决的方法有，
- 如果希望保留服务器上的改动，仅仅并入新配置项，
#+BEGIN_SRC shell
git stash
git pull
git stash pop
git diff -w +filename    ;;确认代码自动合并
#+END_SRC
- 如果希望用代码库中的文件完全覆盖本地文件，
#+BEGIN_SRC shell
git reset --hard
git pull
#+END_SRC

* 例行性工作调度
主要有两种工作调度方式：
- 一种是例行性的，就是每隔一定的周期要办的事项；
- 一种是突发性的，就是做完以后就没有的那一种；

针对这两种调度需求，Linux 提供了两种功能：
- at：at 是个可以处理仅执行一次就结束调度的指令。要执行 at，必须要有 atd 这个服务的支持。 *fedora27* 现在以及已经默认不安装 atd 服务。
- crontab: crontab 这个指令所设置的工作将会循环进行下去。可执行的时间分为分钟、小时、每周、每月和每年等。crontab 需要 cornd 服务的支持。

** 循环执行的例行性工作调度
crond 服务默认启动，系统提供使用者控制例行性工作调度的指令 (crontab)。为了安全性考虑，可以限制使用 crontab 的使用者账号。使用的限制性数据有：
- /etc/cron.allow: 将可以使用 crontab 的账号写入其中，若不在这个文件内的使用者则不可以使用 crontab;
- /etc/cron.deny: 将不可以使用 crontab 的账号写入其中，若不在这个文件内的使用者则可以使用 crontab;

从优先级上来说，/etc/cron.allow 比 /etc/cron.deny 要高，这两个文件只选择一个来限制，因此，为不影响自己在设置上面的判断，只需保留一个即可。一般是 /etc/cron.deny，添加黑名单比添加白名单方便一点。

当使用者使用 crontab 来建立工作调度条目时，该调度条目会被记录到 /var/spool/cron/中，以用户名来识别。不要直接编辑该文件，因为可能会破坏原有的语法结构而导致任务无法执行。

*** 建立和管理 crontab 条目
**** 通过 crontab 指令
#+BEGIN_EXAMPLE
[userName@localhost ~]# crontab [-u username] [-l;-e;-r]
选项与参数：
-u ：只有 root 才能进行这个任务，亦即帮其他使用者创建/移除 crontab 工作调度；
-e ：编辑 crontab 的工作内容
-l ：查阅 crontab 的工作内容
-r ：移除所有的 crontab 的工作内容，若仅要移除一项，请用 -e 去编辑。
#+END_EXAMPLE

不在 /etc/cron.deny 中的使用者都可以直接使用 "crontab -e" 来编辑例行性命令条目。
*下达指令时以及脚本中最好使用绝对路径，避免找不到函数以及输出不明。*
#+BEGIN_EXAMPLE
[userName@localhost ~]# crontab -e
# 弹出 vi 编辑界面，按照上例的格式编辑即可， *注意* 是 5 颗星
#+END_EXAMPLE

#+BEGIN_CENTER
| 特殊字符 | 含义                                                     |
|----------+----------------------------------------------------------|
| *        | 代表任何时刻都可以接受                                   |
| ，       | 分割时段，"3,6 * * * *" 表示第 3 和第 6 分钟             |
| -        | 一段连续时间，"3-6 * * * *" 表示 3 到 6 分钟             |
| /n       | n 表数字，表示“每隔 n 单位”，"*/5 * * * *" 表每隔 5 分钟 |
#+END_CENTER

**** 通过系统配置文件
"crontab -e" 是针对使用者的 cron 来设计的，对于例行性工作条目的管理，则可以通过管理系统文件的方式来进行。一般来说，crond 默认有三个地方存放脚本配置文件：
- /etc/crontab
- /etc/cron.d/*
- /var/spool/cron/*

#+CAPTION: Example of jod definition in crontab
#+BEGIN_EXAMPLE
[userName@localhost ~]# cat /etc/crontab
SHELL=/bin/bash ; 使用哪种 shell 接口
PATH=/sbin:/bin:/usr/sbin:/usr/bin ; 可执行文件搜寻路径
MAILTO=root ; 若有额外STDOUT，以 email将数据送给谁

# Example of job definition:
# .---------------- minute (0 - 59)
# |  .------------- hour (0 - 23)
# |  |  .---------- day of month (1 - 31)
# |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...
# |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat
# |  |  |  |  |
# *  *  *  *  * user-name  command to be executed
#+END_EXAMPLE

以上是 /etc/crontab 文件中的内容，系统会每分钟对该文件进行扫描。与 crontab -e 的内容相比，不同的部分主要在前面的几行：
- PATH=... : 执行时搜索路径
- MAILTO=root : 当 /etc/crontab 中例行性工作执行发生错误时，或者该工作的执行结果有 STDOUT/STDERR 时，会将错误信息发送到指定用户的邮箱。

#+BEGIN_EXAMPLE
[root@study ~]# ls -l /etc/cron.d
-rw-r--r--. 1 root root 128 Jul 30 2014 0hourly
-rw-r--r--. 1 root root 108 Mar 6 10:12 raid-check
-rw-------. 1 root root 235 Mar 6 13:45 sysstat
-rw-r--r--. 1 root root 187 Jan 28 2014 unbound-anchor
# 其实说真的，除了 /etc/crontab 之外，crond 的配置文件还不少耶！上面就有四个设置！
# 先让我们来瞧瞧 0hourly 这个配置文件的内容吧！
[root@study ~]# cat /etc/cron.d/0hourly
# Run the hourly jobs
SHELL=/bin/bash
PATH=/sbin:/bin:/usr/sbin:/usr/bin
MAILTO=root
01 * * * * root run-parts /etc/cron.hourly
# 瞧一瞧，内容跟 /etc/crontab 几乎一模一样！但实际上是有设置值喔！就是最后一行！
#+END_EXAMPLE

0hourly 文件中执行的函数为 run-parts, 该函数会在一个设定的时间内随机选择一个时间点来执行/etc/cron.hourly 目录内的所有可执行文件。具体的说，如果对定点执行要求不太严格，可以将脚本（或指令）放置到（或链接到）/etc/cron.hourly/ 目录下，该脚本就会被 crond 在每小时的 1 分开始后的 5 分钟内，随机选取一个时间来执行。除了 cron.hourly，/etc 文件夹下还有 cron.daily、cron.weekly 和 cron.monthly 等文件，分别表示每日、每周、每月各执行一次。和 cron.hourly 不同的是，这三个文件是由 anacron 所执行的。

如果需要自定义例行性工作条例，并且不希望每次例行文件更新和重装系统后都要重新输入指令，可在 /etc/cron.d/目录下建立自己的例行脚本文件。

**** 小结
- 用户自己创建例行工作调度，可以直接使用 crontab -e，这样也能保障自己的隐私，因为 /etc/crontab 大家都有读取的权限；
- 系统维护管理使用“ vim /etc/crontab”：如果你这个例行工作调度是系统的重要工作，为了让自己管理方便，同时容易追踪，建议直接写入 /etc/crontab 较佳！
- 自己开发软件使用“ vim /etc/cron.d/newfile”：如果你是想要自己开发软件，那当然最好就是使用全新的配置文件，并且放置于 /etc/cron.d/目录内即可。
- 固定每小时、每日、每周、每天执行的特别工作：如果与系统维护有关，还是建议放置到 /etc/crontab 中来集中管理较好。如果想要偷懒，或者是一定要再某个周期内进行的任务，也可以放置到上面谈到的几个目录中，直接写入指令即可！

**** 注意事项（编自鸟哥的）
- 资源分配不均
当大量使用 crontab 的时候，可能会出现系统在某一时刻特别繁忙的情况，此时的处理办法之一是将任务分开来执行。
#+BEGIN_EXAMPLE
    [userName@localhost ~]# vim /etc/crontab
    1,6,11,16,21,26,31,36,41,46,51,56 * * * * userName CMD1
    2,7,12,17,22,27,32,37,42,47,52,57 * * * * userName CMD2
    3,8,13,18,23,28,33,38,43,48,53,58 * * * * userName CMD3
    4,9,14,19,24,29,34,39,44,49,54,59 * * * * userName CMD4
#+END_EXAMPLE

- 取消不要的输出项目
当有执行成果或者执行的命令中有输出数据时，这些数据会被 mail 给指定的账户。 #+TODO 可以采用数据重定向将输出结果输出到 /dev/null 中。

- 安全检查
很多时候被植入木马都是以例行命令的方式植入的，所以可以借由检查 /var/log/cron 的内容来视察是否有“非您设置的 cron 被执行了。

- 周与日月不可同时并存
容易引起混乱。

**** anacron 唤醒停机期间的工作任务
解决的工况是：在该执行例行性任务时停机了，在开机后重新检查并执行任务。

* 案例
** 案例：centos minimal 安装（virtualbox 下测试）
- 选择 centos minimal ISO 安装；
- 安装之后首先配置网络，输入 nmcli d 查看网络的连接情况，下面是配置之后的网络情况，初始时 enp0s3 状态是 disconnected；

#+BEGIN_EXAMPLE
[root@localhost userName]# nmcli d
DEVICE  TYPE      STATE      CONNECTION
enp0s3  ethernet  connected  enp0s3
lo      loopback  unmanaged  --
#+END_EXAMPLE

- 在终端输入 nmtui，打开网络管理器界面，依次 Edit a connection --> enp0s3 --> <Edit...> --> [X] Automatically connect --> OK。重启网络服务 systemctl restart network；

- 此时，系统中 ipconfig 等命令并不能使用，可输入 ip a 查看结果；
#+BEGIN_EXAMPLE
[root@localhost userName]# ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: enp0s3: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 08:00:27:b5:58:76 brd ff:ff:ff:ff:ff:ff
    inet 10.0.2.15/24 brd 10.0.2.255 scope global noprefixroute dynamic enp0s3
       valid_lft 72435sec preferred_lft 72435sec
    inet6 fe80::479:586:1f5f:4672/64 scope link noprefixroute
       valid_lft forever preferred_lft forever
#+END_EXAMPLE

- 此时应该可以连接互联网，ping 一下看看；

- 安装网络工具包 net-tools，常用的 ifconfig 和 netstat 等命令即可使用；
#+BEGIN_EXAMPLE
yum install net-tools
#+END_EXAMPLE

- ssh 配置，检查 OpenSSH 是否安装，默认已经安装；
#+BEGIN_EXAMPLE
$ yum list installed | grep openssh-server
#+END_EXAMPLE

- 配置 /etc/ssh/sshd_config 文件；
#+BEGIN_SRC shell
Port 22  # 打开 22 号端口
#AddressFamily any
ListenAddress 0.0.0.0
ListenAddress ::
...
PasswordAuthentication yes
...
UseDNS no  # 这一行很多网上教程都没有提到，在 virtualbox 环境中，配置这一行之后才能顺利 ssh 进来（XSHELL 中测试）

#+END_SRC

- virtualbox 环境中选择关闭防火墙；

*** CentOS 添加 yum 源
- 安装 EPEL 源，EPEL官网地址：https://fedoraproject.org/wiki/EPEL， CentOS用户可以直接安装并启用EPEL 源（需 root 权限）
#+BEGIN_EXAMPLE
[root@localhost userName]# yum repolist
Loaded plugins: fastestmirror
Loading mirror speeds from cached hostfile
 * base: mirrors.nwsuaf.edu.cn
 * extras: mirrors.shu.edu.cn
 * updates: mirrors.zju.edu.cn
repo id                                        repo name                                        status
base/7/x86_64                                  CentOS-7 - Base                                  9,911
extras/7/x86_64                                CentOS-7 - Extras                                  403
updates/7/x86_64                               CentOS-7 - Updates                               1,348
repolist: 11,662
#+END_EXAMPLE

#+BEGIN_EXAMPLE
[root@localhost userName]# yum install epel-release
Loaded plugins: fastestmirror
Loading mirror speeds from cached hostfile
 * base: mirrors.nwsuaf.edu.cn
 * extras: mirrors.shu.edu.cn
 * updates: mirrors.zju.edu.cn
Resolving Dependencies
--> Running transaction check
---> Package epel-release.noarch 0:7-11 will be installed
--> Finished Dependency Resolution

Dependencies Resolved

======================================================================================================
 Package                     Arch                  Version                Repository             Size
======================================================================================================
Installing:
 epel-release                noarch                7-11                   extras                 15 k

Transaction Summary
======================================================================================================
Install  1 Package

Total download size: 15 k
Installed size: 24 k
Is this ok [y/d/N]: y
Downloading packages:
epel-release-7-11.noarch.rpm                                                   |  15 kB  00:00:15
Running transaction check
Running transaction test
Transaction test succeeded
Running transaction
  Installing : epel-release-7-11.noarch                                                           1/1
  Verifying  : epel-release-7-11.noarch                                                           1/1

Installed:
  epel-release.noarch 0:7-11

Complete!
#+END_EXAMPLE

再查看源，EPEL 安装完成
#+BEGIN_EXAMPLE
[root@localhost userName]# yum repolist
Loaded plugins: fastestmirror
Loading mirror speeds from cached hostfile
 * base: mirrors.nwsuaf.edu.cn
 * epel: mirrors.tuna.tsinghua.edu.cn
 * extras: mirrors.shu.edu.cn
 * updates: mirrors.zju.edu.cn
repo id                          repo name                                                      status
base/7/x86_64                    CentOS-7 - Base                                                 9,911
epel/x86_64                      Extra Packages for Enterprise Linux 7 - x86_64                 12,686
extras/7/x86_64                  CentOS-7 - Extras                                                 403
updates/7/x86_64                 CentOS-7 - Updates                                              1,348
repolist: 24,348
#+END_EXAMPLE
更多关于 yum 源配置：
https://blog.itnmg.net/2012/09/17/centos-yum-source/

https://www.tecmint.com/enable-rpmforge-repository/

http://www.live-in.org/archives/998.html

https://centos.pkgs.org/7/repoforge-x86_64/
